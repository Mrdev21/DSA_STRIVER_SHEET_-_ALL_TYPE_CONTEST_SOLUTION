
1.A. Sleeping Through Classes

time limit per test

1 second

memory limit per test

256 megabytes

You have n classes today, which are numbered from 1 to n.

The classes are described by a binary string∗ s of length n. We call class i important if and only if si=1. For each important class, you must stay awake and listen to it.

You are very tired and wish to sleep through as many classes as possible. However, falling asleep takes time. If you listen to an important class i, then you cannot fall asleep for the next k classes, i.e., you must also stay awake in classes i+1,i+2,…,i+k (or until the end of the day, if fewer than k classes remain).

For classes that are not important, you may sleep through them unless the rule above forces you to stay awake.

Your task is to find out the maximum number of classes you can sleep through today.

∗A binary string is a string where each character is either 0 or 1.

Input

Each test contains multiple test cases. The first line contains the number of test cases t (1≤t≤500). The description of the test cases follows.

The first line of each test case contains two integers n and k (1≤n,k≤100).

The second line of each test case contains the string s of length n (si=0 or 1).

Output

For each test case, output a single integer — the maximum number of classes you can sleep through today.

Example

Input

Copy

4

4 1

1001

3 3

000

3 1

001

8 2

01000101

Output

Copy

1
3
2
2

Note

In the first test case, you must listen to class 1 and class 4. After listening to class 1, you cannot fall asleep in class 2. So the only class you can sleep through is class 3.

In the second test case, you can sleep through all the classes.

In the fourth test case, you can only sleep through classes 1 and 5.



B. Niko's Tactical Cards


time limit per test

1.5 seconds

memory limit per test

256 megabytes

Niko is playing a game. Her score is denoted by an integer k which is 0 initially.

The game has n turns. On the i-th turn, Niko is given a red card with an integer ai on it, as well as a blue card with an integer bi on it. She must choose exactly one of the cards and update her score according to her choice:

- If she chooses the red card, her score becomes k−ai, where k is her score before the turn.
- If she chooses the blue card, her score becomes bi−k, where k is her score before the turn.

After this, the game proceeds to the next turn, or ends if it is the n-th turn.

Your task is to find the maximum possible score Niko can obtain at the end of the game.

Input

Each test contains multiple test cases. The first line contains the number of test cases t (1≤t≤103). The description of the test cases follows.

The first line of each test case contains a single integer n (1≤n≤105) — the number of turns.

The second line of each test case contains n integers a1,a2,…,an (−109≤ai≤109).

The third line of each test case contains n integers b1,b2,…,bn (−109≤bi≤109).

It is guaranteed that the sum of n over all test cases does not exceed 105.

Output

For each test case, output a single integer — the maximum possible score Niko can obtain at the end of the game.

Example

Input

Copy

3

3

4 -8 -1

-3 -7 0

5

-3 1 0 7 1

-5 3 -1 4 -5

5

-7 7 5 4 9

-9 -3 3 2 2

Output

Copy

6
12
27

Note

In the first test case, one optimal strategy is as follows:

|   |   |   |   |   |
|---|---|---|---|---|
|Turn|0|1|2|3|
|Card Chosen|—|Blue|Red|Red|
|Score|0|−3−0=−3|−3−(−8)=5|5−(−1)=6|

In the second test case, one optimal strategy is as follows:

|   |   |   |   |   |   |   |
|---|---|---|---|---|---|---|
|Turn|0|1|2|3|4|5|
|Card Chosen|—|Blue|Blue|Blue|Blue|Red|
|Score|0|−5|8|−9|13|12|



C. Kanade's Perfect Multiples



In the afterlife school, Kanade studies a peculiar number game.

She gives you two integers n and k, as well as an array a consisting of n integers, where 1≤ai≤k holds.

For an integer set B={b1,b2,…,bm} where 1≤bi≤k, we call it complete if and only if both of the following hold:

- For each 1≤i≤n, at least one divisor of ai is contained in B;
- For each 1≤j≤m, all positive multiples of bj which are less than or equal to k appear in the array a at least once.

You have to find a complete set B with minimum possible size, or determine that no such set exists.

Input

Each test contains multiple test cases. The first line contains the number of test cases t (1≤t≤104). The description of the test cases follows.

The first line of each test case contains two integers n and k (1≤n≤2⋅105, 1≤k≤109) — the length of a and the upper bound of elements of a.

The second line contains n integers a1,a2,…,an (1≤ai≤k) — the elements of a.

It is guaranteed that the sum of n over all test cases does not exceed 2⋅105.

Output

For each test case:

- If no complete set B exists, print a single integer −1 in the only line of output.
- Otherwise:
    - First print a single integer m (1≤m≤n) in the first line of output — the size of B. Note that you have to minimize the size of B.
    - Then output m integers b1,b2,…,bm (1≤bi≤k) in the second line — the set you constructed.

If there are multiple answers, you may print any of them.

Example

Input

Copy

4

4 6

3 2 4 6

5 5

1 2 3 4 5

3 6

2 3 6

1 2

2

Output

Copy

2

2 3 

1

1 

-1

1

2 

Note

In the first test case, B={2,3} works. For b=2, all multiples {2,4,6} (up to k=6) appear in a; for b=3, multiples {3,6} appear. Every ai is divisible by 2 or 3. No single b can satisfy both conditions, so m=2 is minimal.

In the second test case, B={1} satisfies both rules since every number is divisible by 1 and all multiples of 1 up to k appear.



D. Taiga's Carry Chains



After classes at Ohashi High School, Ryuuji hands Taiga a non-negative integer n and sets a simple challenge.

They will play for exactly k moves. In a single move, Taiga chooses a non-negative integer ℓ and sets n←n+2ℓ.

Ryuuji defines the score of one move as the number of binary carries that occur when adding 2ℓ to the current number in base 2. The total score is the sum of score over all k moves.

Taiga wants the total score to be as large as possible after k moves. What is the maximum total score she can achieve?

Input

Each test contains multiple test cases. The first line contains the number of test cases t (1≤t≤1000). The description of the test cases follows.

The only line of each test case contains two integers n and k (1≤n<230, 0≤k≤109) — the initial integer and the number of moves.

Output

For each test case, output a single integer — the maximum total score that Taiga can achieve.

Example

Input

Copy

6

7 1

13 2

42 2

1048576 100

23 2

371 1

Output

Copy

3

4

3

100

5

3

Note

In the first test case, (n,k)=(7,1) and 7=1112. Adding 20 gives 111+1=1000, which produces carries at bits 0,1,2. So the total score is 3.

In the second test case, (n,k)=(13,2) with 13=11012. First we add 20: 1101+0001=1110, which creates one carry. Then we add 21: 1110+0010=10000, with carries propagating through bits 1,2,3. In total there are 1+3=4 carries, so the score is 4.

In the third test case, (n,k)=(42,2) and 42=1010102. First we add 21: 101010+000010=101100, giving one carry. Next we add 22: 101100+000100=110000, which generates carries at bits 2 and 3. Thus the total number of carries is 1+2=3.

In the fifth test case, (n,k)=(23,2) and 23=101112. First we add 20: 10111+00001=11000, which produces carries at bits 0,1,2. Then we add 23: 11000+01000=100000, producing carries at bits 3 and 4. Altogether there are 3+2=5 carries, so the



E. Shiro's Mirror Duel



time limit per test

3 seconds

memory limit per test

256 megabytes

There's no such thing as luck in this world. The victor is decided before the game even starts.

— No Game No Life

This is an interactive problem.

One day, Sora and Shiro feel bored again, so they decide to settle it with a game.

At the beginning, Sora gives Shiro a permutation∗ p1,p2,…,pn of length n. In each operation, Shiro may select two distinct indices x and y (1≤x≠y≤n). Then Sora flips a fair coin:

- With probability 0.5, Sora swaps px and py;
- With probability 0.5, Sora swaps pn−x+1 and pn−y+1.

After the operation, Sora replies with the actual pair of indices that were swapped, so that Shiro can update her local permutation accordingly.

Shiro's goal is to sort the permutation p in ascending order by using at most ⌊2.5n+800⌋ operations. Help her!

∗A permutation of length n is an array consisting of n distinct integers from 1 to n in arbitrary order. For example, [2,3,1,5,4] is a permutation, but [1,2,2] is not a permutation (2 appears twice in the array), and [1,3,4] is also not a permutation (n=3 but there is 4 in the array).

Input

Each test contains multiple test cases. The first line contains the number of test cases t (1≤t≤100). The description of the test cases follows.

The first line of each test case contains a single integer n (1≤n≤4000) — the length of p.

The second line contains n integers p1,p2,…,pn — the elements of p.

It is guaranteed that the sum of n over all test cases does not exceed 2⋅104.

It is guaranteed that there are 50 tests in this problem.

Interaction

For each test case, you can use at most ⌊2.5n+800⌋ moves to sort the permutation p in ascending order.

To make a move, you should print a new line in the following format:

- ?xy (1≤x≠y≤n) — the two indices that Shiro selects in this move.

As a response to the move, you will receive two integers u and v — the actual pair of indices that Sora swapped. It is guaranteed that (u,v) is randomly selected from (x,y) and (n−x+1,n−y+1) with equal probability.

To report that the permutation has been sorted in ascending order, you should print a new line with a single character !. This does not count as one of the ⌊2.5n+800⌋ moves.

After that, proceed to the next test case or terminate the program if it was the last test case.

After printing each query do not forget to output the end of line and flush∗ the output. Otherwise, you will get Idleness limit exceeded verdict.

If, at any interaction step, you read −1 instead of valid data, your solution must exit immediately. This means that your solution will receive Wrong answer because of an invalid query or any other mistake. Failing to exit can result in an arbitrary verdict because your solution will continue to read from a closed stream.

Hacks are disabled in this problem.

∗To flush, use:

- fflush(stdout) or cout.flush() in C++;
- sys.stdout.flush() in Python;
- see the documentation for other languages.

Example

Input

Copy

2
5
5 1 3 4 2

1 5

2 1

2
1 2

Output

Copy

? 1 5

? 4 5

!


!

Note

In the first test case, n=5 and the initial permutation is [5,1,3,4,2].

- We print ? 1 5. The judge replies 1 5, meaning positions 1 and 5 are swapped (no mirroring). The array becomes [2,1,3,4,5].
- We print ? 4 5. The judge replies 2 1, which is the mirror of 4,5 because with n=5 we have n−4+1=2 and n−5+1=1. Thus we must swap positions 2 and 1. The array becomes [1,2,3,4,5].
- The permutation is now sorted, so we print !. The answer line does not count toward the operation limit.

In the second test case, the given permutation is already increasing, so we just need to output !.


F. Isla's Memory Thresholds


— Plastic Memories

In the world of Plastic Memories, Isla is collecting n memory fragments. The i-th fragment has size ai, and the sizes are non-increasing, that is, a1≥a2≥⋯≥an.

During retrieval, Isla processes fragments on a range and stores their sizes into a buffer. Whenever the buffer reaches a given threshold x, it overflows: one capsule is recorded, and the buffer is cleared to zero.

There are q independent queries, each described by a triple (l,r,x). For each query, x denotes Isla's memory capacity. Isla then picks up the i-th memory fragment one by one for each l≤i≤r. At any moment, if the total size of the fragments she is currently holding is at least x, she clears her memory completely (keeping nothing). You must determine how many times Isla clears her memory and the final sum of the size of the fragments she holds.

Input

Each test contains multiple test cases. The first line contains the number of test cases t (1≤t≤1000). The description of the test cases follows.

The first line of each test case contains two integers n and q (1≤n,q≤150,000) — the length of a and the number of queries.

The second line of each test case contains n integers a1,a2,…,an (1≤ai≤109) — the elements of a. It is guaranteed that a1≥a2≥⋯≥an.

Then q lines follow, each containing three integers l, r, and x (1≤l≤r≤n, 1≤x≤109) — a query.

It is guaranteed that the sum of n over all test cases does not exceed 150,000.

It is guaranteed that the sum of q over all test cases does not exceed 150,000.

Output

For each test case, output two integers for each query — the number of times Isla clears her memory and the final sum of the size of the fragments she holds.

Example

Input

Copy

3

5 4

7 5 5 2 1

1 3 10

2 5 6

1 5 7

3 5 4

6 5

6 6 5 3 2 2

1 6 2

1 6 7

2 6 7

2 5 4

2 5 3

11 7

938412006 792864920 746880066 729862150 704473377 550436315 381392172 326088331 316506801 301443698 190862681

1 3 417253102

9 11 857592497

1 11 344359921

1 7 408760015

8 8 544749974

7 10 361090133

3 11 888178376

Output

Copy

1 5

1 3

2 3

1 3

6 0

2 4

2 0

3 0

3 2

3 0

0 808813180

9 0

6 381392172

0 326088331

2 301443698

3 492306379

Note

Let cnt be how many times Isla has cleared her memory, and sum be the total size of the fragments she is holding.

In the first test case, for the first query (l,r,x)=(1,3,10):

- start with sum=0;
- add a1=7⇒sum=7 (still <10);
- add a2=5⇒sum=12≥10⇒sum←0, cnt←1;
- add a3=5⇒sum=5.

Thus, we print cnt=1 and sum=5.

In the second test case, for the fifth query (l,r,x)=(2,5,3):

- start with sum=0;
- add a2=6⇒sum=6≥3⇒sum←0, cnt←1;
- add a3=5⇒sum=5≥3⇒sum←0, cnt←2;
- add a4=3⇒sum=3≥3⇒sum←0, cnt←3;
- add a5=2⇒sum=2 (still <3);

Thus, we print cnt=3 and sum=2.